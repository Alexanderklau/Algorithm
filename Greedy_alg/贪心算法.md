# 贪心算法

## 原理解析

也称为贪婪算法，从某个初始解出发，逼近给定的目标。当不能继续前进的时候，就停止算法，给出个近似解。

## 贪心算法的注意事项

1. 不能拿来求最大/最小的问题解
2. 只能拿来求满足某些约束条件的可行解范围
3. 不能保证可以获得最优解

## 贪心算法的基本流程
1. 从某个初始解出发
2. while 走向总目标
3. 求出一个解
4. 求出所有解元素的一个可行解

## 例子

### 找零算法

```
假设 只有 1 分、 2 分、 5 分、 

1 角、 2 角、 5 角、 

1 元 面值 的 硬币。 

在 超市 结账 时， 如果 需要 找 零钱， 

收银员 希望 将 最少 的 硬币 数 找 给 顾客。 

那么， 给定 需 要找 的 零钱 数目， 如何 求得 最少 的 硬币 数 呢？
```

算法题真的，有些时候我真想说，你们能不能讲人话，不要搞这种sb例子

这个用代码表示就是

```
[0.01, 0.02, 0,05, 0.1, 0.2, 0.5, 1.0]

给你一个n，你要保证，列表里面的一个或者多个值相加，等于n，求出等于n的元素最少的是多少。
```

分析一下，首先，假设，假设n = 1.0

那么有这么几种算法

1. 0.5 + 0.5 = 1.0
2. 1.0
3. 0.2 + 0.5 + 0.2 + 0.1 = 1.0
4. ...

所以分析一下

算法步骤最少的，就是直接拿出1.0或者是0.5 + 0.5，这说明什么，也就是硬币越大，相加为n的次数越少.

所以，这道题的算法解析步骤如下

1. 首先，计算出一共有多少银币，或者是一共有多少钱，这里需要知道每种硬币的数量
2. 开始贪心循环，要想用的硬币数量最少，需要利用所有大面值的硬币，因此从数组的 大面值的元素遍历

``` python
while i >= 0:
    if sumall > a[i]:
        n = int(sumall / a[i])
        if n >= b[i]:
            n = b[i]
        sumall -= n * a[i]
        print("用了{num}个{cash}硬币".format(num = n, cash = a[i]))
    i -= 1
```





